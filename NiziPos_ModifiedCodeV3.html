<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NiziPOS™ B20 Simulator with Image Upload</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background-color: #f0f0f0;
    }
    .main-container {
      max-width: 1200px;
      margin: 20px auto;
    }
    .main-wrapper {
      border-radius: 8px;
      overflow: hidden;
      display: grid;
      grid-template-columns: 2fr 1fr;
    }
    .control-section,
    .monitor-section {
      background-color: white;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .header-text {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 20px;
      color: #333;
      padding: 10px 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    .device-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .speed-selector {
      padding: 8px;
      width: 150px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .action-button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .action-button:hover {
      background-color: #45a049;
    }
    .action-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .command-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .command-field {
      flex: 1;
      padding: 8px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: monospace;
    }
    .control-button {
      padding: 8px 12px;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .control-button:hover {
      background-color: #1976D2;
    }
    .control-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .monitor-header {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .monitor-display {
      height: 700px;
      overflow-y: auto;
      background-color: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      font-family: monospace;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }
    .log-item {
      margin-bottom: 5px;
      line-height: 1.4;
      word-wrap: break-word;
      word-break: break-word;
      white-space: pre-wrap;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .log-info {
      color: #666;
    }
    .log-error {
      color: #f44336;
    }
    .log-success {
      color: #4CAF50;
    }
    .log-sent {
      color: #2196F3;
    }
    .log-timeout {
      color: #ff9800;
      font-style: italic;
    }
    .log-warning {
      color: #ff9800;
    }
    .commands-section {
      display: none;
    }
    .commands-section.visible {
      display: block;
    }
    .input-label {
      display: block;
      font-weight: bold;
      margin-bottom: 5px;
      color: #333;
    }
    .input-group {
      display: flex;
      flex-direction: column;
      flex: 1;
    }
    .error-message {
      color: #f44336;
      font-size: 12px;
      margin-top: 4px;
      display: none;
    }
    .error-message.visible {
      display: block;
    }
    .truncated-message {
      cursor: pointer;
    }
    .full-message {
      display: none;
      margin-top: 5px;
      padding: 5px;
      background-color: #f0f0f0;
      border-radius: 4px;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-x: auto;
    }
    .drop-area {
      border: 3px dashed #ccc;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      background-color: #f9f9f9;
      transition: all 0.3s ease;
      margin-bottom: 15px;
    }
    .drop-area.highlight {
      border-color: #4CAF50;
      background-color: #e8f5e9;
    }
    .drop-area p {
      font-size: 14px;
      color: #666;
      margin: 0;
    }
    .preview {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 10px;
    }
    .preview img {
      max-width: 100%;
      max-height: 200px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .progress-bar {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 4px;
      margin: 10px 0;
      display: none;
    }
    .progress {
      height: 20px;
      background-color: #4CAF50;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s;
    }
    .image-previews {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .image-controls {
      margin-top: 10px;
      display: flex;
      gap: 10px;
    }
    .device-selector-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .device-selector-content {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .device-selector-content h2 {
      margin-top: 0;
      font-size: 20px;
      color: #333;
    }
    .device-list {
      margin: 20px 0;
      max-height: 200px;
      overflow-y: auto;
    }
    .device-item {
      padding: 10px;
      border-bottom: 1px solid #ddd;
      cursor: pointer;
    }
    .device-item:hover {
      background-color: #f0f0f0;
    }
    .device-selector-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
  </style>
</head>
<body>
  <div class="main-container">
    <div class="main-wrapper">
      <div class="control-section">
        <div class="header-text">NiziPOS™ B20 Simulator</div>
        <div class="device-controls">
          <div class="device-controls-item">Select Baud Rate</div>
          <select id="speedSelector" class="speed-selector">
            <option value="9600">9600</option>
            <option value="19200">19200</option>
            <option value="38400">38400</option>
            <option value="57600">57600</option>
            <option value="115200" selected>115200</option>
          </select>
          <button id="connectionButton" class="action-button">Connect</button>
        </div>
        <div id="commandsSection" class="commands-section">
          <div class="command-container">
            <div class="input-group">
              <label class="input-label">Image Upload</label>
              <div id="dropArea" class="drop-area">
                <p>Connect to device, then drag & drop an image here or click to select</p>
                <input type="file" id="fileInput" accept="image/jpeg,image/png,image/bmp" style="display: none;" multiple>
              </div>
              <div class="progress-bar" id="progressBar">
                <div class="progress" id="progress"></div>
              </div>
              <div class="preview">
                <img id="preview" style="display: none;">
                <div id="imagePreviews" class="image-previews"></div>
                <div class="image-controls">
                  <button id="startLoopButton" class="control-button" disabled>Start Loop</button>
                  <button id="stopLoopButton" class="control-button" disabled>Stop Loop</button>
                  <button id="clearAllImagesButton" class="control-button" disabled>Clear All Images</button>
                </div>
              </div>
            </div>
          </div>
          <div class="command-container">
            <div class="input-group">
              <label class="input-label">Image Controls</label>
              <button id="clearImageButton" class="control-button" disabled>Clear Image</button>
            </div>
          </div>
        </div>
      </div>
      <div class="monitor-section">
        <div class="monitor-header">
          <span>Serial Logs</span>
          <div style="display: flex; gap: 10px; align-items: center;">
            <label for="showTimeouts" style="font-size: 12px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
              <input type="checkbox" id="showTimeouts" style="margin: 0;">
              <span>Show Timeouts</span>
            </label>
            <button onclick="clearMonitor()" class="control-button" style="padding: 4px 10px; font-size: 12px;">Clear</button>
          </div>
        </div>
        <div id="monitorDisplay" class="monitor-display"></div>
      </div>
    </div>
  </div>

  <!-- Device Selector Modal -->
  <div id="deviceSelectorModal" class="device-selector-modal">
    <div class="device-selector-content">
      <h2>Select CH341 Device</h2>
      <div id="deviceList" class="device-list"></div>
      <div class="device-selector-buttons">
        <button id="cancelSelectionButton" class="control-button">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    // Device connection variables
    let devicePort = null;
    let dataReader = null;
    let dataWriter = null;
    let isDeviceConnected = false;
    let readInProgress = false;
    let transferInProgress = false;
    let transferAborted = false;
    let imageDisplayed = false;
    const FRAME_MAGIC = new Uint32Array([0xAA55CC33])[0];
    const TRANSFER_TIMEOUT = 15000;
    let lastTransferActivity = Date.now();
    let transferTimeoutChecker = null;
    let uploadedImages = [];
    let currentImageIndex = 0;
    let imageLoopInterval = null;
    const MAX_IMAGES = 6;
    const IMAGE_DISPLAY_INTERVAL = 6000;
    const TRANSITION_DELAY = 50;

    // DOM elements
    const connectionButton = document.getElementById('connectionButton');
    const monitorDisplay = document.getElementById('monitorDisplay');
    const commandsSection = document.getElementById('commandsSection');
    const showTimeoutsCheckbox = document.getElementById('showTimeouts');
    const dropArea = document.getElementById('dropArea');
    const fileInput = document.getElementById('fileInput');
    const preview = document.getElementById('preview');
    const clearImageButton = document.getElementById('clearImageButton');
    const deviceSelectorModal = document.getElementById('deviceSelectorModal');
    const deviceList = document.getElementById('deviceList');
    const cancelSelectionButton = document.getElementById('cancelSelectionButton');

    // Command definitions
    const commands = [
      { id: 'logoCommand', label: 'Display Logo', value: 'IDLE', placeholder: 'FSREAD**test.txt' },
      { id: 'textDisplayCommand', label: 'Text Display', value: 'TEXT**Main Title**Subtitle Text**Message', placeholder: 'TEXT**Topic**Title**Message' },
      { id: 'qrCommand', label: 'QR Payload', value: 'QR**Rs. 123.45**QRPayloadData', placeholder: 'QR**Amount**PayloadData' },
      { id: 'loadingCommand', label: 'Loading Command', value: 'WAIT**Rs. 560.50**Please wait...', placeholder: 'WAIT**Amount**Message' },
      { id: 'successCommand', label: 'Success Command', value: 'PASS**SUCCESS!**Payment successful', placeholder: 'PASS**Title**Message' },
      { id: 'failCommand', label: 'Failure Command', value: 'FAIL**Rs. 560.50**Payment Failed', placeholder: 'FAIL**Amount**Message' },
      { id: 'warnCommand', label: 'Warning', value: 'WARN**Device Not Ready**Please wait', placeholder: 'WARN**Title**Message' },
      { id: 'infoCommand', label: 'Information', value: 'INFO**Important**Keep device connected', placeholder: 'INFO**Title**Message' },
      { id: 'sleepCommand', label: 'Sleep Device', value: 'RESET', placeholder: 'RESET' },
      { id: 'formatCommand', label: 'Format Image', value: 'FORMAT', placeholder: 'FORMAT' },
      { id: 'wakeCommand', label: 'Wake Device', value: 'WAKE', placeholder: 'WAKE' },
      { id: 'screentimeCommand', label: 'Screen Time', value: 'SCREENTIME**60', placeholder: 'SCREENTIME**<time in seconds (30-300)>' }
    ];

    // Initialize the interface
    function initializeInterface() {
      generateCommandInterface();
      setupEventListeners();
      
      if (!('serial' in navigator)) {
        addMonitorEntry('Web Serial API is not supported in your browser. Please use Chrome/Edge.', 'error');
        connectionButton.disabled = true;
        clearImageButton.disabled = true;
      } else {
        addMonitorEntry('Web Serial API is supported. Checking for CH341 devices...', 'info');
        checkForCH341Devices();
      }
    }

    // Check for CH341 devices and connect automatically if single device is found
    async function checkForCH341Devices() {
      try {
        const ports = await navigator.serial.getPorts();
        const ch341Ports = ports.filter(port => {
          const info = port.getInfo();
          return info.usbVendorId === 0x1A86; // CH341 Vendor ID
        });

        if (ch341Ports.length === 1) {
          // Single CH341 device found, connect automatically
          addMonitorEntry('Single CH341 device detected, connecting automatically...', 'info');
          devicePort = ch341Ports[0];
          await connectToDevice();
        } else if (ch341Ports.length > 1) {
          // Multiple CH341 devices found, show selection modal
          addMonitorEntry('Multiple CH341 devices detected, please select a device.', 'info');
          showDeviceSelector(ch341Ports);
        } else {
          addMonitorEntry('No CH341 devices detected. Click Connect to select a port manually.', 'info');
        }
      } catch (error) {
        addMonitorEntry(`Error checking for CH341 devices: ${error.message}`, 'error');
        connectionButton.disabled = false;
      }
    }

    // Show device selector modal for multiple devices
    function showDeviceSelector(ports) {
      deviceList.innerHTML = '';
      ports.forEach((port, index) => {
        const deviceItem = document.createElement('div');
        deviceItem.className = 'device-item';
        deviceItem.textContent = `Device ${index + 1} (CH341)`;
        deviceItem.onclick = async () => {
          devicePort = port;
          deviceSelectorModal.style.display = 'none';
          await connectToDevice();
        };
        deviceList.appendChild(deviceItem);
      });

      cancelSelectionButton.onclick = () => {
        deviceSelectorModal.style.display = 'none';
        addMonitorEntry('Device selection cancelled.', 'info');
        connectionButton.disabled = false;
      };

      deviceSelectorModal.style.display = 'flex';
    }

    // Generate command interface
    function generateCommandInterface() {
      commands.forEach(cmd => {
        const container = document.createElement('div');
        container.className = 'command-container';
        
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group';
        
        const label = document.createElement('label');
        label.setAttribute('for', cmd.id);
        label.className = 'input-label';
        label.textContent = cmd.label;
        
        const input = document.createElement('input');
        input.id = cmd.id;
        input.className = 'command-field';
        input.value = cmd.value;
        input.placeholder = cmd.placeholder || '';
        
        const button = document.createElement('button');
        button.textContent = 'Send';
        button.className = 'control-button';
        button.onclick = () => executeCommand(cmd.id);
        
        inputGroup.appendChild(label);
        inputGroup.appendChild(input);
        container.appendChild(inputGroup);
        container.appendChild(button);
        commandsSection.appendChild(container);
      });

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
      });

      ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, highlight, false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, unhighlight, false);
      });

      dropArea.addEventListener('drop', handleDrop, false);
      dropArea.addEventListener('click', () => {
        if (isDeviceConnected) {
          fileInput.click();
        } else {
          addMonitorEntry('Please connect to device first', 'error');
        }
      });
      
      fileInput.setAttribute('multiple', 'true');
      fileInput.addEventListener('change', handleFileSelect);
    }

    function setupEventListeners() {
      connectionButton.addEventListener('click', handleConnection);
      clearImageButton.addEventListener('click', clearImage);
      window.addEventListener('beforeunload', cleanupBeforeUnload);
      document.addEventListener('visibilitychange', handleVisibilityChange);
      document.getElementById('startLoopButton').addEventListener('click', startImageLoop);
      document.getElementById('stopLoopButton').addEventListener('click', stopImageLoop);
      document.getElementById('clearAllImagesButton').addEventListener('click', clearAllImages);
    }

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function highlight() {
      if (isDeviceConnected) {
        dropArea.classList.add('highlight');
      }
    }

    function unhighlight() {
      dropArea.classList.remove('highlight');
    }

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        handleMultipleFiles(files);
      }
    }

    function handleFileSelect(e) {
      if (e.target.files.length > 0) {
        handleMultipleFiles(e.target.files);
      }
    }

    async function handleMultipleFiles(files) {
      if (!isDeviceConnected || !devicePort || !dataWriter) {
        addMonitorEntry('Not connected to device. Please connect first.', 'error');
        return;
      }

      const imageFiles = Array.from(files).filter(file => 
        file.type.match('image/jpeg|image/png|image/bmp')
      );

      if (imageFiles.length === 0) {
        addMonitorEntry('No valid image files selected. Please upload JPEG, PNG, or BMP files.', 'error');
        return;
      }

      if (uploadedImages.length + imageFiles.length > MAX_IMAGES) {
        addMonitorEntry(`Cannot add ${imageFiles.length} images. Maximum ${MAX_IMAGES} images allowed.`, 'error');
        return;
      }

      try {
        for (const file of imageFiles) {
          const reader = new FileReader();
          await new Promise((resolve, reject) => {
            reader.onload = function(e) {
              const imageData = e.target.result;
              uploadedImages.push({
                file: file,
                data: imageData
              });
              resolve();
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
          });
        }

        updateImagePreviews();
        document.getElementById('clearAllImagesButton').disabled = !isDeviceConnected;
        document.getElementById('startLoopButton').disabled = !isDeviceConnected || uploadedImages.length === 0;
        
        addMonitorEntry(`Added ${imageFiles.length} image(s). Total images: ${uploadedImages.length}`, 'success');
      } catch (error) {
        addMonitorEntry(`Error processing images: ${error.message}`, 'error');
      }
    }

    function updateImagePreviews() {
      const previewsContainer = document.getElementById('imagePreviews');
      previewsContainer.innerHTML = '';
      
      uploadedImages.forEach((image, index) => {
        const previewDiv = document.createElement('div');
        previewDiv.className = 'image-preview-item';
        previewDiv.style.position = 'relative';
        previewDiv.style.margin = '5px';
        
        const img = document.createElement('img');
        img.src = image.data;
        img.style.maxWidth = '100px';
        img.style.maxHeight = '100px';
        img.style.objectFit = 'contain';
        img.style.border = '1px solid #ccc';
        img.style.borderRadius = '4px';
        
        const removeButton = document.createElement('button');
        removeButton.textContent = '×';
        removeButton.style.position = 'absolute';
        removeButton.style.top = '-8px';
        removeButton.style.right = '-8px';
        removeButton.style.background = 'red';
        removeButton.style.color = 'white';
        removeButton.style.border = 'none';
        removeButton.style.borderRadius = '50%';
        removeButton.style.width = '20px';
        removeButton.style.height = '20px';
        removeButton.style.cursor = 'pointer';
        removeButton.style.fontSize = '14px';
        removeButton.style.lineHeight = '1';
        removeButton.style.padding = '0';
        removeButton.onclick = () => removeImage(index);
        
        const imageNumber = document.createElement('div');
        imageNumber.textContent = `#${index + 1}`;
        imageNumber.style.position = 'absolute';
        imageNumber.style.bottom = '0';
        imageNumber.style.left = '0';
        imageNumber.style.background = 'rgba(0,0,0,0.7)';
        imageNumber.style.color = 'white';
        imageNumber.style.padding = '2px 5px';
        imageNumber.style.fontSize = '12px';
        imageNumber.style.borderRadius = '0 4px 0 0';
        
        previewDiv.appendChild(img);
        previewDiv.appendChild(removeButton);
        previewDiv.appendChild(imageNumber);
        previewsContainer.appendChild(previewDiv);
      });

      const startLoopButton = document.getElementById('startLoopButton');
      const stopLoopButton = document.getElementById('stopLoopButton');
      
      startLoopButton.disabled = !isDeviceConnected || uploadedImages.length === 0 || imageLoopInterval !== null;
      stopLoopButton.disabled = !isDeviceConnected || imageLoopInterval === null;
    }

    function removeImage(index) {
      uploadedImages.splice(index, 1);
      updateImagePreviews();
      if (uploadedImages.length === 0) {
        stopImageLoop();
      }
    }

    async function sendImageToDevice(file) {
      if (!isDeviceConnected || !devicePort || !dataWriter) {
        throw new Error('Not connected to device');
      }

      try {
        await ensureWriterReady();
        await dataWriter.write(new TextEncoder().encode('START_RTIMAGE\n'));
        addMonitorEntry('Sent START_RTIMAGE', 'info');
        await new Promise(resolve => setTimeout(resolve, 100));

        const arrayBuffer = await file.arrayBuffer();
        const imageData = new Uint8Array(arrayBuffer);
        
        const header = new ArrayBuffer(8);
        const headerView = new DataView(header);
        headerView.setUint32(0, FRAME_MAGIC, true);
        headerView.setUint32(4, imageData.length, true);
        
        await dataWriter.write(new Uint8Array(header));
        addMonitorEntry(`Sent image header: ${imageData.length} bytes`, 'info');

        const ready = await waitForReadySignal();
        if (!ready) {
          throw new Error('Device not ready for data');
        }
        addMonitorEntry('Device ready for image data', 'info');

        if (!transferAborted) {
          await dataWriter.write(imageData);
          addMonitorEntry(`Sent image data: ${imageData.length} bytes`, 'info');
        } else {
          throw new Error('Transfer aborted');
        }

        const result = await waitForAckSignal();
        if (result === 'success') {
          addMonitorEntry('Image sent successfully', 'success');
        } else {
          throw new Error('Device reported error receiving image');
        }
      } catch (error) {
        throw new Error(`Failed to send image: ${error.message}`);
      }
    }

    async function waitForReadySignal() {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout waiting for ready signal'));
        }, 500);

        window.checkForReadySignal = (data) => {
          for (let i = 0; i < data.length; i++) {
            if (data[i] === 82) {
              clearTimeout(timeout);
              resolve(true);
              return true;
            }
          }
          return false;
        };

        window.abortTransferCallback = () => {
          clearTimeout(timeout);
          reject(new Error('Transfer aborted'));
        };
      });
    }

    async function waitForAckSignal() {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout waiting for acknowledgment'));
        }, 500);

        window.checkForAckSignal = (data) => {
          for (let i = 0; i < data.length; i++) {
            if (data[i] === 75) {
              clearTimeout(timeout);
              resolve('success');
              return true;
            } else if (data[i] === 69) {
              clearTimeout(timeout);
              resolve('error');
              return true;
            }
          }
          return false;
        };

        window.abortTransferCallback = () => {
          clearTimeout(timeout);
          reject(new Error('Transfer aborted'));
        };
      });
    }

    async function clearImage() {
      if (!isDeviceConnected || !devicePort) {
        addMonitorEntry('Not connected to device', 'error');
        return;
      }

      try {
        await ensureWriterReady();
        await dataWriter.write(new TextEncoder().encode('CLEAR_IMAGE\n'));
        addMonitorEntry('Sent clear image command', 'info');
        
        await new Promise(resolve => setTimeout(resolve, 500));
        
        imageDisplayed = false;
        clearImageButton.disabled = true;
        preview.style.display = 'none';
        fileInput.value = '';
        transferInProgress = false;
        transferAborted = false;
        
        uploadedImages = [];
        updateImagePreviews();
        
        addMonitorEntry('Image cleared successfully', 'success');
      } catch (error) {
        addMonitorEntry(`Error clearing image: ${error.message}`, 'error');
        await handleConnectionError(error);
      }
    }

    function startTransferTimeoutChecker() {
      stopTransferTimeoutChecker();
      transferTimeoutChecker = setInterval(() => {
        if (transferInProgress && (Date.now() - lastTransferActivity > TRANSFER_TIMEOUT)) {
          addMonitorEntry('Transfer timeout - no device response', 'error');
          abortTransfer();
        }
      }, 1000);
    }

    function stopTransferTimeoutChecker() {
      if (transferTimeoutChecker) {
        clearInterval(transferTimeoutChecker);
        transferTimeoutChecker = null;
      }
    }

    async function handleConnection() {
      if (connectionButton.disabled) return;
      connectionButton.disabled = true;
      
      try {
        if (!isDeviceConnected) {
          await connectToDevice();
        } else {
          await disconnectDevice();
        }
      } catch (error) {
        addMonitorEntry(`Connection error: ${error.message}`, 'error');
        await cleanupConnections();
        connectionButton.textContent = 'Connect';
        connectionButton.style.backgroundColor = '#4CAF50';
        clearImageButton.disabled = true;
      } finally {
        connectionButton.disabled = false;
      }
    }

    async function connectToDevice() {
      connectionButton.textContent = 'Connecting...';
      connectionButton.style.backgroundColor = '#ff9800';
      
      try {
        if (!devicePort) {
          addMonitorEntry('No device selected. Requesting port...', 'info');
          devicePort = await navigator.serial.requestPort({
            filters: [{ usbVendorId: 0x1A86 }]
          });
        }

        const speedRate = parseInt(document.getElementById('speedSelector').value);
        
        addMonitorEntry(`Attempting to open port at ${speedRate} baud...`, 'info');
        
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
          try {
            await devicePort.open({
              baudRate: speedRate,
              dataBits: 8,
              stopBits: 1,
              parity: 'none',
              flowControl: 'none',
              bufferSize: 1024
            });
            break;
          } catch (error) {
            retryCount++;
            if (retryCount === maxRetries) {
              throw new Error(`Failed to open port after ${maxRetries} attempts: ${error.message}`);
            }
            addMonitorEntry(`Port open attempt ${retryCount} failed, retrying...`, 'warning');
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }

        if (devicePort.setSignals) {
          try {
            await devicePort.setSignals({
              dataTerminalReady: true,
              requestToSend: true
            });
            addMonitorEntry('Port signals configured', 'info');
          } catch (error) {
            addMonitorEntry(`Warning: Could not configure port signals: ${error.message}`, 'warning');
          }
        }

        dataReader = devicePort.readable.getReader();
        dataWriter = devicePort.writable.getWriter();
        isDeviceConnected = true;
        
        connectionButton.textContent = 'Disconnect';
        connectionButton.style.backgroundColor = '#f44336';
        commandsSection.classList.add('visible');
        dropArea.querySelector('p').textContent = 'Drag & drop an image here or click to select';
        
        addMonitorEntry(`Connected to device at ${speedRate} baud`, 'success');
        
        startReading();
        
        return true;
      } catch (error) {
        await cleanupConnections();
        throw new Error(`Connection failed: ${error.message}`);
      }
    }

    async function disconnectDevice(showMessages = true) {
      if (showMessages) addMonitorEntry('Disconnecting...', 'info');
      
      stopImageLoop();
      
      connectionButton.textContent = 'Disconnecting...';
      connectionButton.style.backgroundColor = '#ff9800';
      connectionButton.disabled = true;
      
      try {
        isDeviceConnected = false;
        imageDisplayed = false;
        commandsSection.classList.remove('visible');
        dropArea.querySelector('p').textContent = 'Connect to device first';
        preview.style.display = 'none';
        clearImageButton.disabled = true;
        document.getElementById('clearAllImagesButton').disabled = true;
        document.getElementById('startLoopButton').disabled = true;
        document.getElementById('stopLoopButton').disabled = true;
        
        await cleanupConnections();
        
        connectionButton.textContent = 'Connect';
        connectionButton.style.backgroundColor = '#4CAF50';
        if (showMessages) addMonitorEntry('Disconnected', 'success');
      } catch (error) {
        addMonitorEntry(`Disconnect error: ${error.message}`, 'error');
        throw error;
      } finally {
        connectionButton.disabled = false;
      }
    }

    async function cleanupConnections() {
      try {
        if (dataReader) {
          try {
            await dataReader.cancel();
          } catch (error) {
            console.error('Error canceling reader:', error);
          }
          dataReader.releaseLock();
          dataReader = null;
        }
        
        if (dataWriter) {
          try {
            await dataWriter.close();
          } catch (error) {
            console.error('Error closing writer:', error);
          }
          dataWriter.releaseLock();
          dataWriter = null;
        }
        
        if (devicePort) {
          try {
            await devicePort.close();
          } catch (error) {
            console.error('Error closing port:', error);
          }
          devicePort = null;
        }
      } catch (error) {
        console.error('Cleanup error:', error);
        throw error;
      } finally {
        isDeviceConnected = false;
      }
    }

    function cleanupBeforeUnload() {
      if (isDeviceConnected) {
        cleanupConnectionsSync();
      }
    }

    function cleanupConnectionsSync() {
      try {
        if (dataReader) {
          dataReader.releaseLock();
          dataReader = null;
        }
        if (dataWriter) {
          dataWriter.releaseLock();
          dataWriter = null;
        }
      } catch (error) {
        console.error('Sync cleanup error:', error);
      }
      isDeviceConnected = false;
    }

    function handleVisibilityChange() {
      if (document.visibilityState === 'hidden') {
        if (isDeviceConnected) {
          addMonitorEntry('Tab hidden - pausing communication', 'warning');
        }
      } else if (isDeviceConnected && !readInProgress) {
        addMonitorEntry('Tab visible - resuming communication', 'info');
        startReading();
      }
    }

    async function startReading() {
      readInProgress = true;
      let messageBuffer = '';
      
      try {
        while (devicePort?.readable && isDeviceConnected) {
          try {
            const { value, done } = await dataReader.read();
            if (done) break;
            
            let signalProcessed = false;
            if (window.checkForReadySignal) {
              signalProcessed = window.checkForReadySignal(value);
            }
            if (!signalProcessed && window.checkForAckSignal) {
              signalProcessed = window.checkForAckSignal(value);
            }
            
            if (!signalProcessed) {
              const response = new TextDecoder().decode(value);
              messageBuffer += response;
              
              if (messageBuffer.includes('FRAME_LOST\r\n')) {
                addMonitorEntry('FRAME_LOST detected!', 'error');
                transferAborted = true;
                if (transferInProgress) await abortTransfer();
                messageBuffer = messageBuffer.replace('FRAME_LOST\r\n', '');
              }
              if (messageBuffer.includes('INVALID_CMD\r\n')) {
                addMonitorEntry('Received: INVALID_CMD', 'error');
                messageBuffer = messageBuffer.replace('INVALID_CMD\r\n', '');
              }
              
              const messages = messageBuffer.split(/\r\n|\n/);
              messageBuffer = messages.pop() || '';
              
              for (const msg of messages) {
                if (msg.trim()) {
                  addMonitorEntry(`Received: ${msg.trim()}`, 'success');
                }
              }
            }
            
            lastTransferActivity = Date.now();
          } catch (error) {
            if (isDeviceConnected) {
              addMonitorEntry(`Read error: ${error.message}`, 'error');
              await handleConnectionError(error);
              break;
            }
          }
        }
      } catch (error) {
        console.error('Fatal read error:', error);
        if (isDeviceConnected) {
          addMonitorEntry(`Fatal read error: ${error.message}`, 'error');
          await handleConnectionError(error);
        }
      } finally {
        readInProgress = false;
      }
    }

    async function handleConnectionError(error) {
      addMonitorEntry(`Connection error: ${error.message}`, 'error');
      
      try {
        if (devicePort) {
          await disconnectDevice();
          
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          const success = await connectToDevice();
          if (success) {
            addMonitorEntry('Successfully recovered connection', 'success');
            return true;
          }
        }
      } catch (recoveryError) {
        addMonitorEntry(`Failed to recover connection: ${recoveryError.message}`, 'error');
      }
      
      connectionButton.textContent = 'Connect';
      connectionButton.style.backgroundColor = '#4CAF50';
      clearImageButton.disabled = true;
      return false;
    }

    async function executeCommand(commandId) {
      if (!isDeviceConnected || !devicePort || !dataWriter) {
        addMonitorEntry('Please connect to device first', 'error');
        return;
      }
      
      if (imageLoopInterval) {
        stopImageLoop();
        addMonitorEntry('Image loop stopped due to new command', 'info');
      }
      
      const commandElement = document.getElementById(commandId);
      const commandValue = commandElement.value.trim();
      
      if (!commandValue) {
        addMonitorEntry('Command cannot be empty', 'error');
        return;
      }

      if (commandId === 'screentimeCommand') {
        const timeMatch = commandValue.match(/SCREENTIME\*\*(\d+)/);
        if (!timeMatch) {
          addMonitorEntry('Invalid SCREENTIME format. Use SCREENTIME**<seconds>', 'error');
          return;
        }
        const timeValue = parseInt(timeMatch[1]);
        if (timeValue < 30 || timeValue > 300) {
          addMonitorEntry('Screen time must be between 30 and 300 seconds', 'error');
          return;
        }
      }
      
      try {
        await ensureWriterReady();
        await dataWriter.write(new TextEncoder().encode(`${commandValue}\n`));
        addMonitorEntry(`Sent command: ${commandValue}`, 'sent');
        if (commandValue === 'IDLE' || commandValue === 'CLEAR' || commandValue === 'RESET') {
          imageDisplayed = false;
          clearImageButton.disabled = true;
          preview.style.display = 'none';
        }
      } catch (error) {
        addMonitorEntry(`Command error: ${error.message}`, 'error');
        await handleConnectionError(error);
      }
    }

    async function ensureWriterReady() {
      if (!devicePort || !dataWriter) {
        throw new Error('Device not connected');
      }
      
      try {
        if (dataWriter.locked) {
          await new Promise(resolve => setTimeout(resolve, 50));
          if (dataWriter.locked) {
            throw new Error('Writer is locked');
          }
        }
      } catch (error) {
        throw new Error(`Writer not ready: ${error.message}`);
      }
    }

    async function abortTransfer() {
      if (transferInProgress) {
        try {
          await dataWriter.write(new TextEncoder().encode('ABORT\n'));
          addMonitorEntry('Sent abort command', 'warning');
        } catch (error) {
          console.error('Abort error:', error);
        }
        transferAborted = true;
        transferInProgress = false;
        if (window.abortTransferCallback) {
          window.abortTransferCallback();
        }
      }
    }

    function clearMonitor() {
      monitorDisplay.innerHTML = '';
      addMonitorEntry('Monitor cleared', 'info');
    }

    function addMonitorEntry(message, type = 'info') {
      if (type === 'timeout' && !showTimeoutsCheckbox.checked) return;
      
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = document.createElement('div');
      logEntry.className = `log-item log-${type}`;
      
      if (message.length > 100) {
        const shortMessage = document.createElement('div');
        shortMessage.className = 'truncated-message';
        shortMessage.textContent = `[${timestamp}] ${message.substring(0, 100)}... (click to expand)`;
        
        const fullMessage = document.createElement('div');
        fullMessage.className = 'full-message';
        fullMessage.textContent = message;
        
        shortMessage.onclick = function() {
          fullMessage.style.display = fullMessage.style.display === 'block' ? 'none' : 'block';
          this.textContent = fullMessage.style.display === 'block' ?
            `[${timestamp}] ${message.substring(0, 100)}... (click to collapse)` :
            `[${timestamp}] ${message.substring(0, 100)}... (click to expand)`;
        };
        
        logEntry.appendChild(shortMessage);
        logEntry.appendChild(fullMessage);
      } else {
        logEntry.textContent = `[${timestamp}] ${message}`;
      }
      
      monitorDisplay.appendChild(logEntry);
      monitorDisplay.scrollTop = monitorDisplay.scrollHeight;
    }

    async function startImageLoop() {
      if (!isDeviceConnected || uploadedImages.length === 0) {
        return;
      }

      stopImageLoop();
      currentImageIndex = 0;

      const startLoopButton = document.getElementById('startLoopButton');
      const stopLoopButton = document.getElementById('stopLoopButton');
      
      startLoopButton.disabled = true;
      stopLoopButton.disabled = false;

      async function displayNextImage() {
        if (!isDeviceConnected || uploadedImages.length === 0) {
          stopImageLoop();
          return;
        }

        try {
          await ensureWriterReady();
          await dataWriter.write(new TextEncoder().encode('START_RTIMAGE\n'));
          await new Promise(resolve => setTimeout(resolve, TRANSITION_DELAY));

          const currentImage = uploadedImages[currentImageIndex];
          
          const arrayBuffer = await currentImage.file.arrayBuffer();
          const imageData = new Uint8Array(arrayBuffer);
          
          const header = new ArrayBuffer(8);
          const headerView = new DataView(header);
          headerView.setUint32(0, FRAME_MAGIC, true);
          headerView.setUint32(4, imageData.length, true);
          
          await dataWriter.write(new Uint8Array(header));
          
          const ready = await waitForReadySignal();
          if (!ready) {
            throw new Error('Device not ready for data');
          }

          await dataWriter.write(imageData);
          
          const result = await waitForAckSignal();
          if (result !== 'success') {
            throw new Error('Device reported error receiving image');
          }

          currentImageIndex = (currentImageIndex + 1) % uploadedImages.length;
          
          addMonitorEntry(`Displaying image ${currentImageIndex + 1} of ${uploadedImages.length}`, 'info');
        } catch (error) {
          addMonitorEntry(`Error in image loop: ${error.message}`, 'error');
          stopImageLoop();
        }
      }

      await displayNextImage();
      
      imageLoopInterval = setInterval(displayNextImage, IMAGE_DISPLAY_INTERVAL);
      addMonitorEntry('Started image loop', 'info');
    }

    function stopImageLoop() {
      if (imageLoopInterval) {
        clearInterval(imageLoopInterval);
        imageLoopInterval = null;
        
        const startLoopButton = document.getElementById('startLoopButton');
        const stopLoopButton = document.getElementById('stopLoopButton');
        
        startLoopButton.disabled = !isDeviceConnected || uploadedImages.length === 0;
        stopLoopButton.disabled = true;
        
        addMonitorEntry('Image loop stopped', 'info');
      }
    }

    async function clearAllImages() {
      if (!isDeviceConnected || !devicePort) {
        addMonitorEntry('Not connected to device', 'error');
        return;
      }

      try {
        stopImageLoop();
        uploadedImages = [];
        updateImagePreviews();
        
        await ensureWriterReady();
        await dataWriter.write(new TextEncoder().encode('CLEAR_IMAGE\n'));
        addMonitorEntry('Cleared all images', 'success');
        
        document.getElementById('clearAllImagesButton').disabled = true;
        document.getElementById('startLoopButton').disabled = true;
        document.getElementById('stopLoopButton').disabled = true;
      } catch (error) {
        addMonitorEntry(`Error clearing images: ${error.message}`, 'error');
        await handleConnectionError(error);
      }
    }

    document.addEventListener('DOMContentLoaded', initializeInterface);
  </script>